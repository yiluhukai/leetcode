//åœ¨ç»å…¸æ±‰è¯ºå¡”é—®é¢˜ä¸­ï¼Œæœ‰ 3 æ ¹æŸ±å­åŠ N ä¸ªä¸åŒå¤§å°çš„ç©¿å­”åœ†ç›˜ï¼Œç›˜å­å¯ä»¥æ»‘å…¥ä»»æ„ä¸€æ ¹æŸ±å­ã€‚ä¸€å¼€å§‹ï¼Œæ‰€æœ‰ç›˜å­è‡ªä¸Šè€Œä¸‹æŒ‰å‡åºä¾æ¬¡å¥—åœ¨ç¬¬ä¸€æ ¹æŸ±å­ä¸Š(å³æ¯ä¸€ä¸ªç›˜å­åª
//èƒ½æ”¾åœ¨æ›´å¤§çš„ç›˜å­ä¸Šé¢)ã€‚ç§»åŠ¨åœ†ç›˜æ—¶å—åˆ°ä»¥ä¸‹é™åˆ¶: 
//(1) æ¯æ¬¡åªèƒ½ç§»åŠ¨ä¸€ä¸ªç›˜å­; 
//(2) ç›˜å­åªèƒ½ä»ŽæŸ±å­é¡¶ç«¯æ»‘å‡ºç§»åˆ°ä¸‹ä¸€æ ¹æŸ±å­; 
//(3) ç›˜å­åªèƒ½å åœ¨æ¯”å®ƒå¤§çš„ç›˜å­ä¸Šã€‚ 
//
// è¯·ç¼–å†™ç¨‹åºï¼Œç”¨æ ˆå°†æ‰€æœ‰ç›˜å­ä»Žç¬¬ä¸€æ ¹æŸ±å­ç§»åˆ°æœ€åŽä¸€æ ¹æŸ±å­ã€‚ 
//
// ä½ éœ€è¦åŽŸåœ°ä¿®æ”¹æ ˆã€‚ 
//
// ç¤ºä¾‹1: 
//
//  è¾“å…¥ï¼šA = [2, 1, 0], B = [], C = []
// è¾“å‡ºï¼šC = [2, 1, 0]
// 
//
// ç¤ºä¾‹2: 
//
//  è¾“å…¥ï¼šA = [1, 0], B = [], C = []
// è¾“å‡ºï¼šC = [1, 0]
// 
//
// æç¤º: 
//
// 
// Aä¸­ç›˜å­çš„æ•°ç›®ä¸å¤§äºŽ14ä¸ªã€‚ 
// 
// Related Topics é€’å½’ 
// ðŸ‘ 69 ðŸ‘Ž 0
package main

/*
	ä½¿ç”¨å¾ªçŽ¯è§£å†³æ±‰è¯ºå¡”é—®é¢˜ï¼š
	æŒ‰ç…§ç¾Žå›½å­¦è€…çš„æ€è·¯ï¼šæ±‰è¯ºå¡”é—®é¢˜å¯ä»¥åˆ†ä¸¤éƒ¨åŽ»å®Œæˆï¼Œåœ¨è¿›è¡Œè¿™ä¸¤æ­¥ä¹‹å‰ï¼Œéœ€è¦ä¸€äº›å‡†å¤‡å·¥ä½œã€‚
	å°†ä¸‰æ ¹æŸ±å­æ‘†æˆå“å­—å½¢ï¼ŒAåœ¨æœ€ä¸Šé¢ï¼Œå½“ç›˜å­æ•°é‡ä¸ºå¥‡æ•°æ—¶ï¼ŒæŸ±å­çš„é¡ºåºé¡ºæ—¶é’ˆä¸ºACB. ->1
	å½“ç›˜å­çš„ä¸ªæ•°ä¸ºå¶æ•°æ—¶,ç›˜å­çš„é¡ºåºé¡ºæ—¶é’ˆä¸ºABC.

	æŽ¥ä¸‹æ¥é‡å¤ä¸¤ä¸ªæ­¥éª¤ï¼š
	1. å°†æœ€å°çš„ç›˜å­ç§»åŠ¨åˆ°ä¸€ä¸ªæŸ±å­ä¸Š(é¡ºæ—¶é’ˆçš„æ–¹å‘)
	2. æ¯”è¾ƒå¦å¤–ä¸¤ä¸ªæŸ±å­ä¸Šï¼Œå½“æœ‰ä¸€ä¸ªæŸ±å­ä¸ºç©ºæ—¶ï¼Œå°†ç›˜å­ä»Žéžç©ºçš„ç§»åŠ¨åˆ°ç©ºçš„æŸ±å­ä¸Šï¼Œ
	å½“ä¸¤ä¸ªéƒ½éžç©ºæ—¶ï¼ŒæŠŠè¾ƒå°çš„é‚£ä¸ªç§»åŠ¨è¾ƒå¤§å“ªä¸€ä¸ªæŸ±å­ä¸Šã€‚
	é‡å¤ä¸Šé¢ä¸¤ä¸ªåŠ¨ä½œï¼Œç›´åˆ°æ‰€ä»¥çš„ç›˜å­éƒ½ç§»åŠ¨åˆ°CæŸ±å­ä¸Šã€‚
 */
//è§£ç­”æˆåŠŸ:
//æ‰§è¡Œè€—æ—¶:0 ms,å‡»è´¥äº†100.00% çš„Goç”¨æˆ·
//  å†…å­˜æ¶ˆè€—:1.9 MB,å‡»è´¥äº†16.48% çš„Goç”¨æˆ·
//leetcode submit region begin(Prohibit modification and deletion)
/*
	ä½¿ç”¨é€’å½’çš„æ€æƒ³åŽ»è§£å†³è¿™ä¸ªé—®é¢˜ï¼š
	æŠŠNä¸ªç›˜å­ä¸­çš„N-1ä¸ªç›˜å­çœ‹æˆä¸€ä¸ªæ•´ä½“ï¼Œå…ˆæŠŠN-1ä¸ªç›˜å­ç§»åŠ¨åˆ°ä¸­é—´æŸ±ï¼Œå†æŠŠç¬¬Nä¸ªç›˜å­ç§»åŠ¨åˆ°ç›®æ ‡æŸ±ã€‚
	æŽ¥ä¸‹æ¥å†æŠŠN-1ä¸ªç›˜å­ç§»åŠ¨ç§»åŠ¨åˆ°ç›®æ ‡æŸ±ã€‚
	ã€‚ã€‚ã€‚
	æŠŠæœ€ä¸Šé¢çš„ç›˜å­ç§»åŠ¨åˆ°ç›®æ ‡æŸ±ã€‚
*/
func hanota(A []int, B []int, C []int) []int {
	moveToTarget(len(A),&A,&B,&C)
	return C
}

//  æŠŠç›˜å­ç§»åŠ¨åˆ°ç›®æ ‡æŸ±
func moveToTarget(size int,start ,center,target *[]int){
	// é€’å½’çš„ç»ˆæ­¢æ¡ä»¶
	if size == 1{
		move(start,target)
		return
	}

	// å‡½æ•°ä½“å’Œé€’æŽ¨å…³ç³»
	// ç§»åŠ¨N-1ä¸ªç›˜å­åˆ°ä¸­é—´æŸ±å­
	moveToTarget(size-1,start,target,center)
	// ç§»åŠ¨ç¬¬Nä¸ªç›˜å­åˆ°C
	//move(start,target)
	moveToTarget(1,start,center,target)

	//  ç§»åŠ¨N-1ä¸ªç›˜å­åˆ°ç›®æ ‡æŸ±
	moveToTarget(size-1,center,start,target)
}
//  ç§»åŠ¨ä¸€ä¸ªç›˜å­åˆ°å¦ä¸€ä¸ªæŸ±å­
func move(from,to *[]int){
	size:= len(*from)
	*to = append(*to, (*from)[size-1])
	*from = (*from)[:size-1]
}
/*
func hanota(A []int, B []int, C []int) []int {
	// è¿›è¡Œå‡†å¤‡å·¥ä½œï¼Œå¯¹ä¸‰ä¸ªæŸ±å­çš„æ‘†æ”¾é¡ºåºè¿›è¡Œè°ƒæ•´
	size := len(A)
	list := [3]*[]int{}
	list[0] = &A
	if size % 2 ==0 {
		list[1] = &B
		list[2] = &C
	}else{
		list[1] = &C
		list[2] = &B
	}
	//  è®°å½•æœ€å°çš„æŸ±å­çš„ä¸‹æ ‡
	curPosition := 0
	//  å¾ªçŽ¯è¿›è¡ŒæŽ¥ä¸‹æ¥çš„ä¸¤æ­¥æ“ä½œ
	for  len(C) != size {
		// æ‰¾åˆ°æœ€å°çš„æŸ±å­çš„ä¸‹ä¸€ä¸ªä½ç½®
		nextPosition := (curPosition+1)%3
		//  å°†è¿™ä¸ªæŸ±å­çš„ç›˜å­ç§»åŠ¨åˆ°ä¸‹ä¸€ä¸ªä½ç½®
		move(list[curPosition],list[nextPosition])

		prevPosition := curPosition
		curPosition  = nextPosition
		// æŽ¥ç€è¿›è¡Œç¬¬äºŒæ­¥æ“ä½œï¼š
		//å½“æœ‰ä¸€ä¸ªæŸ±å­ä¸ºç©ºæ—¶ï¼Œå°†ç›˜å­ä»Žéžç©ºçš„ç§»åŠ¨åˆ°ç©ºçš„æŸ±å­ä¸Šï¼Œ
		//å½“ä¸¤ä¸ªéƒ½éžç©ºæ—¶ï¼ŒæŠŠè¾ƒå°çš„é‚£ä¸ªç§»åŠ¨è¾ƒå¤§å“ªä¸€ä¸ªæŸ±å­ä¸Šã€‚
		nextPosition = (curPosition + 1)%3

		prev := list[prevPosition]
		next := list[nextPosition]
		// èŽ·å–æŸ±å­æœ€ä¸Šå±‚çš„ç›˜å­
		top1,top2:= math.MaxInt32,math.MaxInt32

		if length:=len(*prev);length!=0 {
			top1 = (*prev)[length-1]
		}
		if length:=len(*next);length!=0 {
			top2 = (*next)[length-1]
		}
		// ç§»åŠ¨è¾ƒå°çš„åˆ°è¾ƒå¤§çš„ä¸Šé¢
		if top1 > top2 {
			move(next,prev)
		}else if top1 < top2{
			move(prev,next)
		}
		//fmt.Printf("a=%#v,B=%#v,c=%#v\n",A,B,C)
	}
	return C
}

func move(from,to *[]int){
	size:= len(*from)
	*to = append(*to, (*from)[size-1])
	*from = (*from)[:size-1]
}
*/


//leetcode submit region end(Prohibit modification and deletion)


